@page "/"
@inject GuessService GuessService;

@implements IDisposable;

@code
{
    readonly string[] _possibleWords = File.ReadAllLines("wordlist.txt");
    List<string>? _filteredWords;

    int guessLines = 1;

    private void Reset()
    {
        guessLines = 1;
        _filteredWords = _possibleWords.ToList();
    }

    private void AddDelGuess(int num)
    {
        guessLines += num;
    }

    protected override void OnInitialized()
    {
        _possibleWords.Shuffle();
        _filteredWords = _possibleWords.ToList();
        GuessService.OnChange += FilterWordList;
    }

    public void Dispose()
    {
        GuessService.OnChange -= FilterWordList;
    }

    private void FilterWordList()
    {
        _filteredWords = new List<string>();

        // check those that have known positions and then later filter those
        if (GuessService.HasPerfectMatch)
        {
            // Use predicate inside Where to avoid repetitive checking
            _filteredWords = _possibleWords.Where(word =>
            {
                return GuessService.Guesses
                    .Where(x => x.State == Letter.LetterState.Right)
                    .All(guess => HasCharAtMatchingPosition(word, guess.Value, guess.Position));
            }).ToList();
        }
        else 
        {
            _filteredWords = _possibleWords.ToList();
        }

        // now filter out the noise
        if (GuessService.HasWronguns)
        {
            _filteredWords.RemoveAll(word =>
            {
                return GuessService.Guesses
                    .Where(x => x.State == Letter.LetterState.Wrong)
                    .Select(x => x.Value)
                    .Any(wrong => word.Contains(wrong));
            });
        }

        if (GuessService.HasImperfections)
        {
            _filteredWords.RemoveAll(word => 
            {
                return GuessService.Guesses
                    .Where(x => x.State == Letter.LetterState.RightWrong)
                    .Any(other => !word.Contains(other.Value) || HasCharAtMatchingPosition(word, other.Value, other.Position));
            });
        }

        StateHasChanged();
    }

    private bool HasCharAtMatchingPosition(string word, string val, int pos)
    {
        return word[pos - 1] == val.ToCharArray()[0];
    }
}

<h1>Blazordle - a Wordle solver</h1>

<p>There are @_possibleWords.Length words in the list.</p>
<p>To start, enter a 5-letter guess and its hints.</p>

<div class="container">
    <div class="wordle-board">
        <!-- Each .wordle-row represents a row for guesses -->

        @for (int i = 1; i <= guessLines; i++)
        {
            <WordleGuess></WordleGuess>
        }
        <button @onclick="() => AddDelGuess(1)">Add</button>
        <button @onclick="() => AddDelGuess(-1)">Del</button>
        <button @onclick="() => Reset()">Reset</button>

    </div>

    <div class="word-list">
        <p>(@_filteredWords.Count possible solutions)</p>
        <ol>
            @foreach (var word in _filteredWords)
            {
                <li>@word</li>
            }
        </ol>
    </div>
</div>